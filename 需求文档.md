
这是基于我们所有讨论最终确定的 **SRS v2.2**。

这份文档包含了：

1. **目录结构优化**：按月归档 (`data/YYYYMM/`)。
    
2. **业务逻辑简化**：移除“暂停栈”，改为“停止即归档+上下文缓存”。
    
3. **同步策略调整**：统一采用“基于时间戳的最后写入优先”原则。
    

它将作为你后续开发 Phase 1 (MVP) 到 Phase 4 (Final) 的核心依据。

---

# 个人时间记录系统 (AtimeLog Clone) - 需求规格说明书 (SRS v2.2)

## 1. 项目概况 (Project Overview)

- **项目名称:** AtimeLog Clone
    
- **目标平台:** Android (Mobile), Windows/Linux (Desktop)
    
- **核心理念:**
    
    - **Simplicity (极简逻辑):** 摒弃复杂的暂停嵌套，采用“停止即归档”策略，降低数据损坏风险。
        
    - **Context Continuity (上下文连续):** 通过 `groupId` 串联碎片化时间，实现跨时段、跨设备的任务接力。
        
    - **Data Sovereignty (数据主权):** 本地 JSON 明文存储，目录结构清晰，按月归档。
        
    - **Offline First (离线优先):** 本地文件系统是唯一真理来源 (Source of Truth)，云端仅作同步备份。
        

---

## 2. 系统架构 (System Architecture)

### 2.1 技术栈 (Tech Stack)

- **开发框架:** Flutter (Dart)
    
- **本地数据库 (Hot Cache):** Isar Database (用于 UI 高频渲染、复杂统计查询)。
    
- **文件存储 (Storage):** 本地文件系统 (JSON 格式)。
    
- **云同步 (Sync):** S3 兼容对象存储 (MinIO / Aliyun OSS)。
    
- **状态管理:** BLoC (推荐) 或 Provider。
    

### 2.2 目录结构规范 (Directory Structure)

采用**按月分文件夹**存储归档数据，保持根目录整洁。

Plaintext

```
/atimelog_data
  ├── config/
  │    └── categories.json       # 全局分类配置
  ├── data/
  │    ├── 202512/               # 按[YYYYMM]命名的文件夹
  │    │    ├── 2025-12-08.json  # 历史归档数据
  │    │    └── 2025-12-08.md    # Obsidian 导出的日报
  │    └── 202601/
  │         └── ...
  └── local/
       └── current_session.json  # 热状态 (当前任务 + 最近上下文)
```

---

## 3. 数据模型设计 (Data Models)

所有 JSON 文件根节点必须包含 `lastUpdated` 字段，用于同步比对。

### 3.1 热状态文件 (Hot State) - `current_session.json`

**用途:** 记录“当前正在进行”的任务，以及“最近进行过”的任务列表（用于快速恢复）。

JSON

```
{
  "deviceId": "pixel-7-pro",
  "lastUpdated": 1733644850000,   // 关键：每次写入时更新为 DateTime.now()
  "current": {                    // 当前正在计时的任务 (若无则为 null)
    "tempId": "uuid-v4-pending",  // 临时唯一ID
    "groupId": "uuid-session-A",  // 会话组ID (核心：用于串联多次碎片时间)
    "categoryId": "work",
    "startTime": 1733644800000,
    "note": "编写需求文档"
  },
  "recentContexts": [             // 最近活动上下文 (用于 UI "点击继续")
    {
      "groupId": "uuid-session-A",
      "categoryId": "work",
      "note": "编写需求文档",
      "lastActiveTime": 1733644800000
    },
    {
      "groupId": "uuid-session-B",
      "categoryId": "reading",
      "note": "学习 Flutter",
      "lastActiveTime": 1733640000000
    }
  ]
}
```

### 3.2 历史归档 (Archive) - `data/YYYYMM/YYYY-MM-DD.json`

**路径规则:** 根据记录的 `startTime` 决定存入哪个年月的文件夹。

JSON

```
{
  "date": "2025-12-08",
  "lastUpdated": 1733641200000,   // 关键：每次追加/修改记录时更新
  "activities": [
    {
      "id": "uuid-v4-final",
      "groupId": "uuid-session-A", // 与 current.groupId 对应
      "categoryId": "work",
      "startTime": "2025-12-08T10:00:00.000",
      "endTime": "2025-12-08T10:30:00.000",
      "duration": 1800,           // 秒
      "note": "编写需求文档",
      "isCrossDaySplit": false    // 是否是被午夜切断的记录
    }
  ]
}
```

### 3.3 分类配置 - `categories.json`

JSON

```
[
  {
    "id": "cat_work",
    "name": "工作",
    "iconCode": 58313, // IconData 的 codePoint
    "colorHex": "#FF5722",
    "order": 1
  }
]
```

---

## 4. 核心功能逻辑 (Functional Requirements)

### 4.1 计时引擎 (Timer Engine)

#### A. 开始新活动 (Start New)

1. **生成:** 创建全新的 `groupId`。
    
2. **构建:** 创建 `current` 对象。
    
3. **写入:** 更新 `current_session.json`，同时更新文件的 `lastUpdated`。
    

#### B. 停止/暂停 (Stop/Pause) - **逻辑归一化**

_注意：UI 上的“暂停”和“停止”底层逻辑一致，都是结束当前切片。_

1. **结算:** 读取内存中的 `current`，计算 duration。
    
2. **归档:** 将记录追加写入 `data/YYYYMM/YYYY-MM-DD.json` (更新该文件 `lastUpdated`)。
    
3. **缓存:** 将该任务信息（含 `groupId`）推入 `recentContexts` 列表头部。
    
4. **清空:** 将 `current_session.json` 的 `current` 置为 `null` (更新该文件 `lastUpdated`)。
    
5. **同步:** 触发后台同步。
    

#### C. 续记/恢复 (Resume)

_场景：从“最近活动”列表中点击某项。_

1. **读取:** 获取选定记录的 `groupId`。
    
2. **启动:** 执行 **[A. 开始]** 流程，但**强制复用旧的 `groupId`**。
    
    - _结果:_ 归档文件中会有多条记录共享同一个 `groupId`，统计时即视为同一任务。
        

#### D. 切换活动 (Switch)

_场景：正在计时 A，直接点击 B。_

1. 执行 **[B. 停止]** (结算 A)。
    
2. 立即执行 **[A. 开始]** (启动 B)。
    

### 4.2 边界与异常处理

#### A. 午夜切断 (Midnight Split)

- **触发:** 跨越 00:00:00。
    
- **操作:**
    
    1. **切断:** 强制结束当前任务 (End: 23:59:59)，归档至 **昨日文件夹/昨日.json**。
        
    2. **重启:** 立即开启新任务 (Start: 00:00:00)，沿用相同 `groupId`。
        
    3. **更新:** 更新热状态 `current` 的 startTime 为 00:00:00。
        
    4. **注意:** 需处理跨月文件夹创建 (如 11.30 -> 12.01)。
        

#### B. 同步策略 (Sync Strategy) - Time Based

- **核心原则:** **Last Write Wins by Timestamp (时间戳最新者胜)**。
    
- **触发时机:** App 启动 (Init)、后台切回 (Resume)、核心数据写入后。
    
- **逻辑流程:**
    
    1. **下载:** 获取云端对应文件（如 `current_session.json`）的内容。
        
    2. **比对:**
        
        - 若 `Cloud.lastUpdated > Local.lastUpdated`: **下载覆盖本地** (UI 刷新)。
            
        - 若 `Local.lastUpdated > Cloud.lastUpdated`: **上传覆盖云端**。
            
        - 若 `Local == Cloud`: 无操作。
            
    3. **容错:** 若本地/云端文件缺失，视其时间戳为 0。
        

---

## 5. 集成需求 (Integrations)

### 5.1 Obsidian 自动导出

- **触发:** 每次 `YYYY-MM-DD.json` 发生写入时。
    
- **路径:** `data/YYYYMM/YYYY-MM-DD.md`。
    
- **格式:** 自动聚合相同 `groupId` 的记录。
    
    - _例如:_ 上午写了3次文档，Markdown 中只显示一行 "编写需求文档 (3h total)"，或者按时间顺序列出但视觉上归类。
        

---

## 6. UI/UX 需求简述

1. **首页 (Home):**
    
    - **Timer Card:** 显示当前计时 (Duration 动态跳动)。
        
    - **Recent Contexts:** 类似 Chip 或 List，显示“最近做的事”，点击即由 `groupId` 续记。
        
    - **Category Grid:** 点击开始全新任务。
        
2. **历史 (History):**
    
    - **聚合视图:** 列表中连续且 `groupId` 相同的记录，默认折叠显示（显示总时长）。
        
    - **详情视图:** 展开后显示具体的碎片时间段 (Start - End)。
        

---

## 7. 开发路线图 (Roadmap)

|**阶段**|**代号**|**核心任务**|**交付目标**|
|---|---|---|---|
|**P1**|**Foundation**|1. 搭建 Flutter 工程<br><br>  <br><br>2. 实现 `data/YYYYMM/` 目录与 JSON 读写类 (含 `lastUpdated` 逻辑)<br><br>  <br><br>3. 实现计时引擎 (Start/Stop/Resume)|**单机版 MVP**<br><br>  <br><br>(能计时、能存文件、文件结构正确)|
|**P2**|**Refinement**|1. 实现午夜切断逻辑<br><br>  <br><br>2. 实现 UI 上的历史记录聚合显示<br><br>  <br><br>3. 完善 `recentContexts` 交互|**完全可用的本地版**<br><br>  <br><br>(逻辑闭环，体验流畅)|
|**P3**|**Cloud Sync**|1. 接入 S3/OSS SDK<br><br>  <br><br>2. 实现基于时间戳的文件双向同步<br><br>  <br><br>3. 处理网络异常|**多端接力版**<br><br>  <br><br>(手机电脑数据互通)|
|**P4**|**Ecosystem**|1. Obsidian MD 生成器<br><br>  <br><br>2. 统计图表<br><br>  <br><br>3. UI 美化与动画|**最终完整版**|
